/*
  June 2012

  BaseFlightPlus Rev -

  An Open Source STM32 Based Multicopter

  Includes code and/or ideas from:

  1)AeroQuad
  2)BaseFlight
  3)CH Robotics
  4)MultiWii
  5)S.O.H. Madgwick

  Designed to run on Naze32 Flight Control Board

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/* ------------------------------------------------------------------------------
  File: matrix3x3.c
  Author: CH Robotics
  Version: 1.0

  Description: Functions for performing operations on 3x3 matrices
------------------------------------------------------------------------------ */

#include "board.h"

/*******************************************************************************
* Function Name  : MatAdd3x3
* Input          : fmat3x3* src1, fmat3x3* src2
* Output         : fmat3x3* dest
* Return         : 0 if failed, 1 if success
* Description    :

Performs the operation: dest = src1 + src2
'dest' can be the same as either src1 or src2
*******************************************************************************/
int MatAdd3x3(fmat3x3 * src1, fmat3x3 * src2, fmat3x3 * dest)
{
    int i, j;

    /*
       sum.data[0][0] = src1->data[0][0] + src2->data[0][0];
       sum.data[0][1] = src1->data[0][1] + src2->data[0][1];
       sum.data[0][2] = src1->data[0][2] + src2->data[0][2];

       sum.data[1][0] = src1->data[1][0] + src2->data[1][0];
       sum.data[1][1] = src1->data[1][1] + src2->data[1][1];
       sum.data[1][2] = src1->data[1][2] + src2->data[1][2];

       sum.data[2][0] = src1->data[2][0] + src2->data[2][0];
       sum.data[2][1] = src1->data[2][1] + src2->data[2][1];
       sum.data[2][2] = src1->data[2][2] + src2->data[2][2];
     */

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            dest->data[i][j] = src1->data[i][j] + src2->data[i][j];
        }
    }

    return 1;
}

/*******************************************************************************
* Function Name  : MatMult3x3
* Input          : fmat3x3* src1, fmat3x3* src2
* Output         : fmat3x3* dest
* Return         : 0 if failed, 1 if success
* Description    :

Performs the operation: dest = src1*src2;

'dest' can be the same as either src1 or src2
*******************************************************************************/
int MatMult3x3(fmat3x3 * src1, fmat3x3 * src2, fmat3x3 * dest)
{
    int i, j;
    fmat3x3 result;

    // First row
    result.data[0][0] = src1->data[0][0] * src2->data[0][0] + src1->data[0][1] * src2->data[1][0] + src1->data[0][2] * src2->data[2][0];
    result.data[0][1] = src1->data[0][0] * src2->data[0][1] + src1->data[0][1] * src2->data[1][1] + src1->data[0][2] * src2->data[2][1];
    result.data[0][2] = src1->data[0][0] * src2->data[0][2] + src1->data[0][1] * src2->data[1][2] + src1->data[0][2] * src2->data[2][2];

    // Second row
    result.data[1][0] = src1->data[1][0] * src2->data[0][0] + src1->data[1][1] * src2->data[1][0] + src1->data[1][2] * src2->data[2][0];
    result.data[1][1] = src1->data[1][0] * src2->data[0][1] + src1->data[1][1] * src2->data[1][1] + src1->data[1][2] * src2->data[2][1];
    result.data[1][2] = src1->data[1][0] * src2->data[0][2] + src1->data[1][1] * src2->data[1][2] + src1->data[1][2] * src2->data[2][2];

    // Third row
    result.data[2][0] = src1->data[2][0] * src2->data[0][0] + src1->data[2][1] * src2->data[1][0] + src1->data[2][2] * src2->data[2][0];
    result.data[2][1] = src1->data[2][0] * src2->data[0][1] + src1->data[2][1] * src2->data[1][1] + src1->data[2][2] * src2->data[2][1];
    result.data[2][2] = src1->data[2][0] * src2->data[0][2] + src1->data[2][1] * src2->data[1][2] + src1->data[2][2] * src2->data[2][2];

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            dest->data[i][j] = result.data[i][j];
        }
    }

    return 1;
}

/*******************************************************************************
* Function Name  : MatInv3x3
* Input          : fmat3x3* src1, fmat3x3* src2
* Output         : fmat3x3* dest
* Return         : 0 if failed, 1 if success
* Description    :

Computes the inverse of the 3x3 matrix in src
*******************************************************************************/
int MatInv3x3(fmat3x3 * src, fmat3x3 * dest)
{
    fmat3x3 inverse;
    int i, j;

    float det = MatDet3x3(src);

    // Invert the matrix
    /*
       | a11 a12 a13 |-1             |   a33a22-a32a23  -(a33a12-a32a13)   a23a12-a22a13  |
       | a21 a22 a23 |    =  1/DET * | -(a33a21-a31a23)   a33a11-a31a13  -(a23a11-a21a13) |
       | a31 a32 a33 |               |   a32a21-a31a22  -(a32a11-a31a12)   a22a11-a21a12  |

       | a00 a01 a02 |-1             |   a22a11-a21a12  -(a22a01-a21a02)   a12a01-a11a02  |
       | a10 a11 a12 |    =  1/DET * | -(a22a10-a20a12)   a22a00-a20a02  -(a12a00-a10a02) |
       | a20 a21 a22 |               |   a21a10-a20a11  -(a21a00-a20a01)   a11a00-a10a01  |
     */

    // Row 1
//       inverse.data[0][0] = (a22a11-a21a12)/det;
    inverse.data[0][0] = (src->data[2][2] * src->data[1][1] - src->data[2][1] * src->data[1][2]) / det;
//       inverse.data[0][1] = -(a22a01-a21a02)/det;
    inverse.data[0][1] = -(src->data[2][2] * src->data[0][1] - src->data[2][1] * src->data[0][2]) / det;
//       inverse.data[0][2] = (a12a01-a11a02)/det;
    inverse.data[0][2] = (src->data[1][2] * src->data[0][1] - src->data[1][1] * src->data[0][2]) / det;

    // Row 2
//       inverse.data[1][0] = -(a22a10-a20a12)/det;
    inverse.data[1][0] = -(src->data[2][2] * src->data[1][0] - src->data[2][0] * src->data[1][2]) / det;
//       inverse.data[1][1] = (a22a00-a20a02)/det;
    inverse.data[1][1] = (src->data[2][2] * src->data[0][0] - src->data[2][0] * src->data[0][2]) / det;
//       inverse.data[1][2] = -(a12a00-a10a02)/det;
    inverse.data[1][2] = -(src->data[1][2] * src->data[0][0] - src->data[1][0] * src->data[0][2]) / det;

    // Row 3
//       inverse.data[2][0] = (a21a10-a20a11)/det;
    inverse.data[2][0] = (src->data[2][1] * src->data[1][0] - src->data[2][0] * src->data[1][1]) / det;
//       inverse.data[2][1] = -(a21a00-a20a01)/det;
    inverse.data[2][1] = -(src->data[2][1] * src->data[0][0] - src->data[2][0] * src->data[0][1]) / det;
//       inverse.data[2][2] = (a11a00-a10a01)/det;
    inverse.data[2][2] = (src->data[1][1] * src->data[0][0] - src->data[1][0] * src->data[0][1]) / det;

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            dest->data[i][j] = inverse.data[i][j];
        }
    }

    return 1;
}

/*******************************************************************************
* Function Name  : MatVectMult3
* Input          : fmat3x3* matrix, fvect3x1* vector
* Output         : fmat3x3* dest
* Return         : 0 if failed, 1 if success
* Description    :

Performs the operation: dest = matrix*vector
*******************************************************************************/
int MatVectMult3(fmat3x3 * matrix, fvect3x1 * vector, fvect3x1 * dest)
{
    fvect3x1 result;
    int i;

    result.data[0] = matrix->data[0][0] * vector->data[0] + matrix->data[0][1] * vector->data[1] + matrix->data[0][2] * vector->data[2];
    result.data[1] = matrix->data[1][0] * vector->data[0] + matrix->data[1][1] * vector->data[1] + matrix->data[1][2] * vector->data[2];
    result.data[2] = matrix->data[2][0] * vector->data[0] + matrix->data[2][1] * vector->data[1] + matrix->data[2][2] * vector->data[2];

    for (i = 0; i < 3; i++) {
        dest->data[i] = result.data[i];
    }

    return 1;
}

/*******************************************************************************
* Function Name  : MatDet3x3
* Input          : fmat3x3* src
* Output         : None
* Return         : The determinant of the matrix
* Description    :

Computes the determinant of the matrix in 'src'
*******************************************************************************/
float MatDet3x3(fmat3x3 * src)
{
    // det = a11(a33a22-a32a23)-a21(a33a12-a32a13)+a31(a23a12-a22a13)
    // det = a00(a22a11-a21a12)-a10(a22a01-a21a02)+a20(a12a01-a11a02)

    return src->data[0][0] * (src->data[2][2] * src->data[1][1] - src->data[2][1] * src->data[1][2])
        - src->data[1][0] * (src->data[2][2] * src->data[0][1] - src->data[2][1] * src->data[0][2])
        + src->data[2][0] * (src->data[1][2] * src->data[0][1] - src->data[1][1] * src->data[0][2]);
}

/*******************************************************************************
* Function Name  : MatTrans3x3
* Input          : fmat3x3* src
* Output         : fmat3x3* dest
* Return         : 0 if failed, 1 if success
* Description    :

Transposes the matrix in 'src', stores the result in 'dest'
*******************************************************************************/
int MatTrans3x3(fmat3x3 * src, fmat3x3 * dest)
{
    fmat3x3 temp;
    int i, j;

    temp.data[0][0] = src->data[0][0];
    temp.data[0][1] = src->data[1][0];
    temp.data[0][2] = src->data[2][0];

    temp.data[1][0] = src->data[0][1];
    temp.data[1][1] = src->data[1][1];
    temp.data[1][2] = src->data[2][1];

    temp.data[2][0] = src->data[0][2];
    temp.data[2][1] = src->data[1][2];
    temp.data[2][2] = src->data[2][2];

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            dest->data[i][j] = temp.data[i][j];
        }
    }

    return 1;
}

/*******************************************************************************
* Function Name  : ScalarMatMult3x3
* Input          : float scal, fmat3x3* src
* Output         : fmat3x3* dest
* Return         : 0 if failed, 1 if success
* Description    :

Multiplies the elements in src by scal and stores the result in dest

*******************************************************************************/
int ScalarMatMult3x3(float scal, fmat3x3 * src, fmat3x3 * dest)
{
    dest->data[0][0] = src->data[0][0] * scal;
    dest->data[0][1] = src->data[0][1] * scal;
    dest->data[0][2] = src->data[0][2] * scal;

    dest->data[1][0] = src->data[1][0] * scal;
    dest->data[1][1] = src->data[1][1] * scal;
    dest->data[1][2] = src->data[1][2] * scal;

    dest->data[2][0] = src->data[2][0] * scal;
    dest->data[2][1] = src->data[2][1] * scal;
    dest->data[2][2] = src->data[2][2] * scal;

    return 1;
}

/*******************************************************************************
* Function Name  : CreateIdentity3x3
* Input          : None
* Output         : fmat3x3* dest
* Return         : Void
* Description    :

Creates a 3x3 identity matrix

*******************************************************************************/
void CreateIdentity3x3(fmat3x3 * dest)
{
    MatZero3x3(dest);

    dest->data[0][0] = 1;
    dest->data[1][1] = 1;
    dest->data[2][2] = 1;
}

/*******************************************************************************
* Function Name  : MatZero3x3
* Input          : None
* Output         : fmat3x3* dest
* Return         : Void
* Description    :

Zeros out all the entries in dest

*******************************************************************************/
void MatZero3x3(fmat3x3 * dest)
{
    dest->data[0][0] = 0;
    dest->data[0][1] = 0;
    dest->data[0][2] = 0;

    dest->data[1][0] = 0;
    dest->data[1][1] = 0;
    dest->data[1][2] = 0;

    dest->data[2][0] = 0;
    dest->data[2][1] = 0;
    dest->data[2][2] = 0;
}

/*******************************************************************************
* Function Name  : MatCopy3x3
* Input          : fmat3x3* src
* Output         : fmat3x3* dest
* Return         : Void
* Description    :

Copies the data in src to dest.

*******************************************************************************/
void MatCopy3x3(fmat3x3 * src, fmat3x3 * dest)
{
    dest->data[0][0] = src->data[0][0];
    dest->data[0][1] = src->data[0][1];
    dest->data[0][2] = src->data[0][2];

    dest->data[1][0] = src->data[1][0];
    dest->data[1][1] = src->data[1][1];
    dest->data[1][2] = src->data[1][2];

    dest->data[2][0] = src->data[2][0];
    dest->data[2][1] = src->data[2][1];
    dest->data[2][2] = src->data[2][2];
}
